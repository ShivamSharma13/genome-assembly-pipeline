#!/usr/bin/env python

#This script takes gunzipped FASTQ files generated by illumina sequencing as input. 
#Sequences are then subject to quality control, de novo assembly via 3 separate tools, then the best assembly is selected via post-assembly QC. 
#This final assembly is then run through BLAST to determine species identification

import subprocess
import argparse
import os
import re
parser = argparse.ArgumentParser()
parser.add_argument("-i", "--input", help="this is input file directory where files are .fq")
parser.add_argument("-o", "--outputfile", help="this is the name of the output file")
inputarguments = parser.parse_args()
if inputarguments.input:
	file_directory = inputarguments.input
else:
	print("error, file directory needed")
	
if inputarguments.outputfile:
	output_file = inputarguments.outputfile
else:
	print("error, output file needed")



def quality_control(file_directory):	#Function utlizing fastqc and fastp 
	i = 1
	file_list = []
	for filename in os.listdir(file_directory):
		myfile = file_directory + '/' + filename	#calls unzipped .fq files
		if "html" not in filename:
			listname = "./fastqc_output/" + filename[:-3] + "_fastqc.zip"
			file_list.append(listname)
		print("files beingp processed:" + filename)
		subprocess.call(["./FastQC/fastqc", myfile, "-j", "./jdk8u232-b09/bin/java", "-o", "./fastqc_output", "-t", "12", "--extract"])	#performs fastqc
	file_list_sort = sorted(file_list)
	#print(file_list)
	for file in file_list_sort:
		if "_fastqc.zip" in file:
			subprocess.call(["unzip", file, "-d", "./unzipped_fastqc_files/"])	#unzips all generated files
			with open("all_fastq_files_data.txt",'a') as myfi:
				if "_1_" in file:
					myfi.write("./unzipped_fastqc_files/" + file[16:-4] + "/fastqc_data.txt" + '\t') 	#creates a file with the names of all the new unzipped folders and path to fastqc_data.txt for them paired for forward and reverse reads
				elif "_2_" in file:
					myfi.write("./unzipped_fastqc_files/" + file[16:-4] + "/fastqc_data.txt" + '\n') 
			with open("all_fastq_files_paired.txt",'a') as myfi:
				if "_1_" in file:
					myfi.write("./gunzipped_data/" + file[16:-11] + ".fq" + '\t') 	#creates a file with the names of all the original unzipped fastq filaes paired for forward and reverse reads
				elif "_2_" in file:
					myfi.write("./gunzipped_data/" + file[16:-11] + ".fq" + '\n') 

			i += 1
forward_score_library = {}
reverse_score_library = {}
def find_cropping_and_trim(file):
	quality_scores_reached = False
	with open(file, 'r') as data_files:
		sequence_pair = -1
		for line in data_files:		#refers to the paths to each data report for the pre-trim QC
			crop = False
			headcrop = False
			sequence_pair += 1	
			forward_read_report = line.split()[0]
			reverse_read_report = line.split()[1]
			with open(forward_read_report, 'r') as data:
				forward_score_library = {}
				for line in data:
					if ">>Per base sequence quality" in line:
						quality_scores_reached = True
						#print("quality scores reached")
					elif ">>END_MODULE" in line and quality_scores_reached:
						quality_scores_reached = False
						break
					elif quality_scores_reached and "#Base" not in line:
						myline = line.split()
# Makes two dictionaries of each position-qc score pair						
						#print(myline[0])
						if float(myline[1])-5 < 25:
							crop = True
							forward_score_library[myline[0]] = myline[1]
							#print(myline[0])
							if "-" in myline[0]:
								crop_command = str(myline[0].split("-")[1])
							else:
								crop_command = str(myline[0])

			with open(reverse_read_report, 'r') as data:
				reverse_score_library = {}
				for line in data:
					if ">>Per base sequence quality" in line:
						quality_scores_reached = True
						
					elif ">>END_MODULE" in line and quality_scores_reached:
						quality_scores_reached = False
					elif quality_scores_reached and "#Base" not in line:
						myline = line.split()
						
						if float(myline[1])-5 < 25:
							crop = True
							if "-" in myline[0]:
								headcrop_command = str(myline[0].split("-")[1])
							else:
								headcrop_command = str(myline[0])

# Now, original fastq files are called in pairs to be trimmed by fastp
			with open("all_fastq_files_paired.txt", 'r') as trimming_input:
				trimming_pair = trimming_input.readlines()[sequence_pair].split()
				fastqc_file_1 = trimming_pair[0]
				fastqc_file_2 = trimming_pair[1]
				output_name = './trim_output/' + fastqc_file_1[16:-5] + "output_1.fastq"
				output_name_2 = './trim_output/' + fastqc_file_2[16:-5] + "output_2.fastq"
				fail_file = output_name + "fail"
				merged_file = output_name + "merge"
				output_name_json = './trim_output/' + fastqc_file_1[16:-5] + ".json"
				output_name_html = './trim_output/' + fastqc_file_1[16:-5] + ".html"
				quality = "25"
				subprocess.call(["./fastp", "--in1", fastqc_file_1, "--in2", fastqc_file_2, "--stdout", "--out1", output_name, "--out2", output_name_2, "--failed_out", fail_file, "-m", "--merged_out", merged_file, "-l", "50", "-q", quality, "-j", output_name_json, "-h", output_name_html, '-w', '10'])
				

#quality_control(file_directory)
find_cropping_and_trim("all_fastq_files_data.txt")	