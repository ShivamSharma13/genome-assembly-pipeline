#!/usr/bin/env python

#This script takes gunzipped FASTQ files generated by illumina sequencing as input. 
#Sequences are then subject to quality control and trimming
# Installation instructions can be found in the README.md file

import subprocess
import argparse
import os
import re
parser = argparse.ArgumentParser()
parser.add_argument("-i", "--input", help="this is input file directory where files are .fq")
#parser.add_argument("-o", "--outputfile", help="this is the name of the output file")
inputarguments = parser.parse_args()
if inputarguments.input:
	file_directory = inputarguments.input
else:
	print("error, file directory needed")
	


def quality_control(file_directory):	#Function utlizing fastqc and fastp 
	i = 1
	file_list = []
	for filename in os.listdir(file_directory):
		myfile = file_directory + '/' + filename	#calls unzipped .fq files
		if "html" not in filename:
			listname = "./fastqc_output/" + filename[:-3] + "_fastqc.zip"
			file_list.append(listname)
		print("files beingp processed:" + filename)
		subprocess.call(["./FastQC/fastqc", myfile, "-j", "./jdk8u232-b09/bin/java", "-o", "./fastqc_output", "-t", "12", "--extract"])	#performs fastqc
	file_list_sort = sorted(file_list)
	#print(file_list)
	for file in file_list_sort:
		if "_fastqc.zip" in file:
			subprocess.call(["unzip", file, "-d", "./unzipped_fastqc_files/"])	#unzips all generated files
			with open("all_fastq_files_data.txt",'a') as myfi:
				if "_1_" in file:
					myfi.write("./unzipped_fastqc_files/" + file[16:-4] + "/fastqc_data.txt" + '\t') 	#creates a file with the names of all the new unzipped folders and path to fastqc_data.txt for them paired for forward and reverse reads
				elif "_2_" in file:
					myfi.write("./unzipped_fastqc_files/" + file[16:-4] + "/fastqc_data.txt" + '\n') 
			with open("all_fastq_files_paired.txt",'a') as myfi:
				if "_1_" in file:
					myfi.write("./gunzipped_data/" + file[16:-11] + ".fq" + '\t') 	#creates a file with the names of all the original unzipped fastq filaes paired for forward and reverse reads
				elif "_2_" in file:
					myfi.write("./gunzipped_data/" + file[16:-11] + ".fq" + '\n') 

			i += 1
forward_score_list = []
reverse_score_list = []
def find_cropping_and_trim(file, qual="30"):
	quality_scores_reached = False
	with open(file, 'r') as data_files:
		sequence_pair = -1
		for line in data_files:		#refers to the paths to each data report for the pre-trim QC
			crop = False
			headcrop = False
			sequence_pair += 1	
			forward_read_report = line.split()[0]
			reverse_read_report = line.split()[1]
			with open(forward_read_report, 'r') as data:
				forward_score_list = []
				reverse_score_list = []
				length = 0
				for line in data:
					if ">>Per base sequence quality" in line:
						quality_scores_reached = True
						#print("quality scores reached")
					elif ">>END_MODULE" in line and quality_scores_reached:
						quality_scores_reached = False
						break
					elif quality_scores_reached and "#Base" not in line:
						myline = line.split()
# Makes two dictionaries of each position-qc score pair						
						#print(myline[0])
						if "-" in myline[0]:

							if int((myline[0].split("-")[1])) > length:
								length = int((myline[0].split("-")[1]))
						else:
							length = myline[0]
						if float(myline[1]) < 28:
							crop = True
							
							#print(myline[0])
							if "-" in myline[0]:
								crop_command = str(myline[0].split("-")[1])
								forward_score_list.append(crop_command)
							else:
								crop_command = str(myline[0])
								forward_score_list.append(crop_command)
			with open(reverse_read_report, 'r') as data:
				reverse_score_library = {}
				for line in data:
					if ">>Per base sequence quality" in line:
						quality_scores_reached = True
						
					elif ">>END_MODULE" in line and quality_scores_reached:
						quality_scores_reached = False
					elif quality_scores_reached and "#Base" not in line:
						myline = line.split()
						
						if float(myline[1]) < 28:
							if "-" in myline[0]:
								crop_command = str(myline[0].split("-")[1])
								reverse_score_list.append(crop_command)
							else:
								crop_command = str(myline[0])
								reverse_score_list.append(crop_command)

# Now, original fastq files are called in pairs to be trimmed by fastp
			with open("all_fastq_files_paired.txt", 'r') as trimming_input:
				head_command = "0"
				tail_command = "0"
				trimming_pair = trimming_input.readlines()[sequence_pair].split()
				fastqc_file_1 = trimming_pair[0]
				fastqc_file_2 = trimming_pair[1]
				output_name = './test_trim_output/' + fastqc_file_1[16:-5] + "output_1.fastq"
				output_name_2 = './test_trim_output/' + fastqc_file_2[16:-5] + "output_2.fastq"
				fail_file = output_name + "fail"
				merged_file = output_name + "merge"
				output_name_json = './test_trim_output/' + fastqc_file_1[16:-5] + "fastp.json"
				output_name_html = './test_trim_output/' + fastqc_file_1[16:-5] + ".html"
				quality = str(qual)
				halfway_point = int(length) / 2
				#print(halfway_point)
				for i in forward_score_list:
					if int(i) < halfway_point and int(i) < 30:
						head_command = i
				for i in reverse_score_list:
					if int(i) < halfway_point and int(i) < 30:
						tail_command = i
				#print(forward_score_list, reverse_score_list)
				#print("headcrop position: " + head_command + " tail crop position: " + tail_command)
				subprocess.call(["./fastp", "--in1", fastqc_file_1, "--in2", fastqc_file_2, "--stdout", "--out1", output_name, "--out2", output_name_2, "--failed_out", fail_file, "-m", "--merged_out", merged_file, "-l", "75", "-q", quality, "-e", "28", "-j", output_name_json, "-h", output_name_html, '-w', '5', '-f', head_command, "-t", tail_command, "-5", "-3", "-M", "28"])
				

#quality_control(file_directory)
find_cropping_and_trim("all_fastq_files_data.txt")	